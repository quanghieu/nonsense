/*(Copyright)
 *      Microsoft Copyright 2009 - 2015
 *      All rights reserved.
*/
/*(Auto)
    Automatically Generated by TpmPrototypes version 2.2 February 10, 2016 
    Date: Sep 22, 2016 Time: 05:27:05 PM  
*/

#ifndef    _CRYPTPRIME_FP_H_
#define    _CRYPTPRIME_FP_H_

//*** IsPrimeInt()
// This will do a test of an word up to 32-bits in size.
BOOL
IsPrimeInt(
    uint32_t            n
    );

//*** BnIsPrime()
// This function is used when the key sieve is not implemented. This function
// Will try to eliminate some of the obvious things before going on
// to perform MillerRabin as a final verification of primeness.
BOOL
BnIsProbablyPrime(
    bigNum          prime,           // IN:
    RAND_STATE      *rand            // IN: the random state just
                                     //     in case Miller-Rabin is required
    );

//*** MillerRabinRounds()
// Function returns the number of Miller-Rabin rounds necessary to give an
// error probability equal to the security strength of the prime. These values
// are from FIPS 186-3.
UINT32
MillerRabinRounds(
    UINT32           bits           // IN: Number of bits in the RSA prime
    );

//*** MillerRabin()
// This function performs a Miller-Rabin test from FIPS 186-3. It does
// 'iterations' trials on the number. In all likelihood, if the number
// is not prime, the first test fails.
// return type: BOOL
//  TRUE        probably prime
//  FALSE       composite
BOOL
MillerRabin(
    bigNum           bnW,
    RAND_STATE      *rand
    );

#ifdef TPM_ALG_RSA  //%
//*** RsaCheckPrime()
// This will check to see if a number is prime and appropriate for an
// RSA prime.
//
// This has different functionality based on whether we are using key
// sieving or not. If not, the number checked to see if it is divisible by
// the public exponent, then the number is adjusted either up or down
// in order to make it a better candidate. It is then checked for being
// probably prime.
//
// If sieving is used, the number is used to root a sieving process.
//
TPM_RC
RsaCheckPrime(
    bigNum           prime,
    UINT32           exponent,
    RAND_STATE      *rand
    );

//*** AdjustPrimeCandiate()
// This function adjusts the candidate prime so that it is odd and > root(2)/2.
// This allows the product of these two numbers to be .5, which, in fixed point
// notation means that the most significant bit is 1.
// For this routine, the root(2)/2 is approximated with 0xB505 which is, in fixed
// point is 0.7071075439453125 or an error of 0.0001%. Just setting the upper
// two bits would give a value > 0.75 which is an error of > 6%. Given the amount
// of time all the other computations take, reducing the error is not much of
// a cost, but it isn't totally required either.
//
// The function also puts the number on a field boundary.
LIB_EXPORT void
RsaAdjustPrimeCandidate(
    bigNum          prime
    );

//***BnGeneratePrimeForRSA()
// Function to generate a prime of the desired size with the proper attributes
// for an RSA prime.
void
BnGeneratePrimeForRSA(
    bigNum          prime,
    UINT32          bits,
    UINT32          exponent,
    RAND_STATE      *rand
    );
#endif //% TPM_ALG_RSA


#endif  // _CRYPTPRIME_FP_H_
